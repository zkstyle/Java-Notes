## 事务的 四个特征（ACID）
   
   事务具有四个特征：原子性（ Atomicity ）、一致性（ Consistency ）、隔离性（ Isolation ）和持续性（ Durability ）。这四个特性简称为 ACID 特性。
   
   1 、原子性。事务是数据库的逻辑工作单位，事务中包含的各操作要么都做，要么都不做
   
   2 、一致性。事 务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。因此当数据库只包含成功事务提交的结果时，就说数据库处于一致性状态。如果数据库系统 运行中发生故障，有些事务尚未完成就被迫中断，这些未完成事务对数据库所做的修改有一部分已写入物理数据库，这时数据库就处于一种不正确的状态，或者说是 不一致的状态。
   
   3 、隔离性。一个事务的执行不能其它事务干扰。即一个事务内部的操作及使用的数据对其它并发事务是隔离的，并发执行的各个事务之间不能互相干扰。
   
   4 、持续性。也称永久性，指一个事务一旦提交，它对数据库中的数据的改变就应该是永久性的。接下来的其它操作或故障不应该对其执行结果有任何影响。

## Mysql的隔离级别
   以mysql为例，两个命令行客户端分别为A，B；不断改变A的隔离级别，在B端修改数据。
     
   1. 将A的隔离级别设置为read uncommitted(未提交读)
   
   A：启动事务，此时数据为初始状态
      
   B：启动事务，更新数据，但不提交
      
   A：再次读取数据，发现数据已经被修改了，这就是所谓的“脏读”
   
   B：回滚事务
      
   A：**再次读数据，发现数据变回初始状态**
   
   经过上面的实验可以得出结论，事务B更新了一条记录，但是没有提交，此时事务A可以查询出未提交记录。造成脏读现象。未提交读是最低的隔离级别。
   
    
   
   2. 将客户端A的事务隔离级别设置为read committed(读已提交)
      
   A：启动事务，此时数据为初始状态
   
   B：启动事务，更新数据，但不提交
   
   A：再次读数据，发现数据未被修改
   
   B：提交事务
   
   A：**再次读取数据，发现数据已发生变化，说明B提交的修改被事务中的A读到了，这就是所谓的“不可重复读”**
   
   经过上面的实验可以得出结论，已提交读隔离级别解决了脏读的问题，但是出现了不可重复读的问题，即事务A在两次查询的数据不一致，因为在两次查询之间事务B更新了一条数据。已提交读只允许读取已提交的记录，但不要求可重复读。
   
    
   
   3. 将A的隔离级别设置为repeatable read(可重复读)
   
   A：启动事务，此时数据为初始状态
   
   B：启动事务，更新数据，但不提交
   
   A：再次读取数据，发现数据未被修改
   
   B：提交事务
   
   A：再次读取数据，发现数据依然未发生变化，这说明这次可以重复读了
   
   B：插入一条新的数据，并提交
   
   A：**再次读取数据，发现数据依然未发生变化，虽然可以重复读了，但是却发现读的不是最新数据，这就是所谓的“幻读”**
   
   A：提交本次事务，再次读取数据，发现读取正常了
   
   由以上的实验可以得出结论，可重复读隔离级别只允许读取已提交记录，而且在一个事务两次读取一个记录期间，其他事务部的更新该记录。但该事务不要求与其他事务可串行化。例如，当一个事务可以找到由一个已提交事务更新的记录，但是可能产生幻读问题(注意是可能，因为数据库对隔离级别的实现有所差别)。像以上的实验，就没有出现数据幻读的问题
   
    
   
   (四)、将A的隔离级别设置为可串行化(Serializable)
   
   A：启动事务，此时数据为初始状态
   
   B：发现B此时进入了等待状态，原因是因为A的事务尚未提交，只能等待（此时，B可能会发生等待超时）
   
   A：提交事务
   
   B：发现插入成功
   
   serializable完全锁定字段，若一个事务来查询同一份数据就必须等待，直到前一个事务完成并解除锁定为止。是完整的隔离级别，会锁定对应的数据表格，因而会有效率的问题。
   



