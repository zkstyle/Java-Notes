## Explain调优

使用explain语法，对SQL进行解释，根据其结果进行调优：

MySQL 表关联的算法是 Nest Loop Join，是通过驱动表的结果集作为循环基础数据，然后一条一条地通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果：

​     a.　EXPLAIN 结果中，第一行出现的表就是驱动表

​     b.　**对驱动表可以直接排序**，对非驱动表（的字段排序）需要对循环查询的合并结果（临时表）进行排序（Important!），即using temporary; 

​     c. 　[驱动表] 的定义为：1）指定了联接条件时，满足查询条件的**记录行数少的表为[驱动表]**；2）未指定联接条件时，**行数少的表为**[驱动表]（Important!）。

​     d.　**优化的目标**是尽可能减少JOIN中Nested Loop的循环次数，以此保证：**永远用小结果集驱动大结果集**（Important!）！：A JOIN B，A为驱动，A中每一行和B进行循环JOIN，看是否满足条件，所以当A为小结果集时，越快。

​     e.NestedLoopJoin实际上就是通过驱动表的结果集作为循环基础数据，然后一条一条的通过该结果集中的数据作为过滤条件到下一个表中查询数据，然后合并结果。如果还有第三个参与Join，**则再通过前两个表的Join结果集作为循环基础数据**，再一次通过循环查询条件到第三个表中查询数据，如此往复

### 各个列的解释

**table**：显示这一行的数据是关于哪张表的

**type**：这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL

​     type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：**system > const > eq_ref > ref > fulltext > ref_or_null > index_merge > unique_subquery > index_subquery > range > index > ALL**   一般来说，得保证查询至少达到range级别，最好能达到ref。

|  ALL        |  全表扫描

|  index       |  索引全扫描

|  range       |  索引范围扫描，**常用语<,<=,>=,between等操作**

|  ref         |  使用非唯一索引扫描或唯一索引前缀扫描，返回单条记录，常出现在关联查询中，即哪些列或**常量被用于查找索引列**上的值

|  eq_ref      |  类似ref，区别在于使用的是唯一索引，使用**主键/唯一索引的关联**查询。对于每个索引键值，表中只有一条记录匹配，简单来说，就是多表连接中使用primary key或者 unique key作为关联条件。

|  const/system  |  单条记录，系统会把匹配行中的其他列作为常数处理，如**主键或唯一索引查询**

|  null         |  MySQL不访问任何表或索引，直接返回

由上至下，效率越来越高

**possible_keys**：显示可能应用在这张表中的索引。如果为空，没有可能的索引。可以为相关的域从WHERE语句中选择一个合适的语句

**key**： 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引

**key_len**：使用的索引的长度。在不损失精确性的情况下，长度越短越好

**ref**：显示索引的哪一列被使用了，如果可能的话，是一个常数

**rows**：MYSQL认为必须检查的用来返回请求数据的行数

**Extra**：关于MYSQL如何解析查询的额外信息。但坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，结果是检索会很慢

### **extra**

 Distinct:一旦MYSQL找到了与行相联合匹配的行，就不再搜索了

 Not exists: MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索了

 Range checked for each Record（index map:#）:没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一

Using filesort: 看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行


> **优化方法**：
> 1、修改逻辑，不在mysql中使用order by而是在应用中自己进行排序。
> 2、使用mysql索引，将待排序的内容放到索引中，直接利用索引的排序。

 Using index: 列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候

 Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上

 Where used 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题不同连接类型的解释（按照效率高低的顺序排序）

 system 表只有一行：system表。这是const连接类型的特殊情况

 const:表中的一个记录的最大值能够匹配这个查询（索引可以是主键或惟一索引）。因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待

 eq_ref:在连接中，MYSQL在查询时，从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用

 ref:这个连接类型只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好

 range:这个连接类型使用索引返回一个范围中的行，比如使用>或<查找东西时发生的情况

 index: 这个连接类型对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据）

 ALL:这个连接类型对于前面的每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免

 

亲测：

group by会导致Using temporary; Using filesort，将分组字段使用索引即可解决

order by会导致Using filesort，建立索引。数据量占大部分的情况下也会放弃使用索引。[官网优化](https://dev.mysql.com/doc/refman/5.6/en/order-by-optimization.html)

**需要注意的是**：由于 Using filesort是使用算法在 内存中进行排序，MySQL对于排序的记录的大小也是有做限制：max_length_for_sort_data，默认为1024。

**show variables like '%max_length_for_sort_data%';可查看大小**。

## 导致索引失效的原因

**1. 随着表的增长，where条件出来的结果集数据太多，大于数据总量的15%，使得索引失效（会导致CBO计算走索引花费大于走全表）**

在查询条件上没有使用引导列

查询的数量是大表的大部分，应该是30％以上

查询小表,或者返回值大概在10%以上

隐式转换导致索引失效.这一点应当引起重视.也是开发中经常会犯的错误，varchar字段结果给出

由于表的字段值超过定义的长度 默认1024

like "%_" 百分号在前 左模糊查询

单独引用复合索引里非第一位置的索引列

字符型字段为数字时在where条件里不添加引号

对索引列进行运算.需要建立函数索引

not in ,not exist,or

当变量采用的是time变量，而表的字段采用的是date变量时.或相反情况

B-tree索引 is null不会走,is not null会走,位图索引 is null,is not null 都会走 

索引失效的案例：
1. 隐式转换导致索引失效，如字符串不加单引号索引失效，因为这里有一个隐式的类型转换操作，更严重会导致行锁变表锁，降低SQL效率
2. 违反最佳左前缀法则　如果索引了多列，要遵守最左前缀法则，指的是查询从索引的最左前列开始，不跳过索引中间的列。
3. 在索引列上做任何操作(计算、函数、（自动or手动）类型转换)，会导致索引失效而转向全表扫描
4. 存储引擎不能使用索引中范围条件右边的列。（范围之后全失效）
若中间索引列用到了范围（>、<、like等），则后面的索引全失效
5. 尽量使用覆盖索引（只访问索引的查询(索引列和查询列一致)），减少select *
6. Mysql在使用不等于(!=、<>)或like的左模糊的时候无法试用索引会导致全表扫描
7. IS NULL和IS NOT NULL也无法使用索引
8. 少用or，用它来连接时索引会失效