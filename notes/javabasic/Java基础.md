# java基础汇总
## 简要说一下final关键字，final可以用来修饰什么？

final可以修饰类、方法、成员变量

当final修饰类的时候，说明该类不能被继承

当final修饰方法的时候，说明该方法不能被重写

在早期，可能使用final修饰的方法，编译器针对这些方法的所有调用都转成内嵌调用，这样提高效率

当final修饰成员变量时，有两种情况：

如果修饰的是基本类型，说明这个变量的所代表数值永不能变(不能重新赋值)！

如果修饰的是引用类型，该变量所引用的不能变，但引用所代表的对象内容是可变的！

值得一说的是：并不是被final修饰的成员变量就一定是编译期常量了。比如说我们可以写出这样的代码：

> private final int ran = new Random().nextInt(20);

## Exception与Error区别

首先Exception和Error都是继承于Throwable 类，在 Java 中只有 Throwable 类型的实例才可以被抛出（throw）或者捕获（catch），它是异常处理机制的基本组成类型。

Exception和Error体现了JAVA这门语言对于异常处理的两种方式。

Exception是java程序运行中可预料的异常情况，咱们可以获取到这种异常，并且对这种异常进行业务外的处理。

Error是java程序运行中不可预料的异常情况，这种异常发生以后，会直接导致JVM不可处理或者不可恢复的情况。所以这种异常不可能抓取到，比如OutOfMemoryError、NoClassDefFoundError等。

其中的Exception又分为检查性异常和非检查性异常。两个根本的区别在于，检查性异常 必须在编写代码时，使用try catch捕获（比如：IOException异常）。

非检查性异常 在代码编写使，可以忽略捕获操作（比如：ArrayIndexOutOfBoundsException），这种异常是在代码编写或者使用过程中通过规范可以避免发生的。

## 反射机制与方式
- 在反射机制中，总共有如下3种方法可以获取到Class类：
1.Class.forName("类的路径")
2.类名.Class
3.实例.getClass()
- 反射的原理：如果知道一个类的名称/或者它的一个实例对象， 就能获取这个类的所有方法和变量的信息(方法名，变量名，方法，修饰符，类型，方法参数等等所有信息)。

## 请列出5个运行时异常与检查异常
运行时异常:
> ClassCastException(类转换异常)
  IndexOutOfBoundsException(数组越界)
  NullPointerException(空指针)
  ArithmeticException(算术异常)
  ConcurrentModificationException(并发修改异常,hashMap->modCount发生改变时抛出此异常)

检查异常:
> SQLException(SQL异常)
  IOException(IO异常，在对流操作时有可能会出现的异常)
  FileNotFoundException(找不到某个文件时，会抛出该异常)
  ClassNotFoundException(找不到某个类时，会抛出该异常)
  EOFException (输入过程中意外地到达文件尾或流尾，会抛出该异常，常见于对流的操作)

## 有没有有顺序的Map实现类，如果有，他们是怎么实现有序的？
- Hashmap和Hashtable 都不是有序的。
- TreeMap和LinkedHashmap都是有序的。（TreeMap默认是key升序，LinkedHashmap默认是数据插入顺序）
- TreeMap是基于比较器Comparator来实现有序的。LinkedHashmap是基于链表来实现数据插入有序的。

## 抽象类和接口区别
含有abstract修饰符的class即为抽象类，abstract 类不能创建实例对象。含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。

abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以，不能有抽象构造方法或抽象静态方法。如果子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型。

接口（interface）可以说成是抽象类的一种特例，接口中的所有方法都必须是抽象的。接口中的方法定义默认为public abstract类型，接口中的成员变量类型默认为public static final。

下面比较一下两者的语法区别：

1.抽象类可以有构造方法，接口中不能有构造方法。

2.抽象类中可以有普通成员变量，接口中没有普通成员变量

3.抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。(jdk1.8以后接口可以有default方法)

4. 抽象类中的抽象方法的访问类型可以是public，protected和　默认类型，但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。

5. 抽象类中可以包含静态方法，接口中不能包含静态方法(jdk1.8以后接口可以有静态方法)

6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static final类型，并且默认即为public static final类型。

7. 一个类可以实现多个接口，但只能继承一个抽象类。

两者在应用上的区别：

接口更多的是在系统架构设计方法发挥作用，主要用于定义模块之间的通信契约。而抽象类在代码实现方面发挥作用，可以实现代码的重用

## java实例化顺序
1.父类的静态变量，静态代码块（先声明的先执行）

2.子类的静态变量，静态代码块（先声明的先执行）

3.父类的变量和代码块

4.父类的构造函数

5.子类的变量和代码块

6.子类的构造函数

对象的初始化顺序：

+ 首先执行父类静态的内容（假如静态内容里new了一个静态变量，那么先执行静态变量的构造函数和静态代码块和非静态代码块，
+ 如果静态变量的类型就是这个类的本身，就只执行构造函数和非静态代码块），父类静态的内容执行完毕后，接着去执行子类的静态的内容，
+ 当子类的静态内容执行完毕之后，再去看父类有没有非静态代码块，如果有就执行父类的非静态代码块，父类的非静态代码块执行完毕，接着执行父类的构造方法;
+ 父类的构造方法执行完毕之后，它接着去看子类有没有非静态代码块，如果有就执行子类的非静态代码块。子类的非静态代码块执行完毕再去执行子类的构造方法。
+ 总之一句话，静态代码块内容先执行，接着执行父类非静态代码块和构造方法，然后执行子类非静态代码块和构造方法。 


## 请结合OO设计理念，谈谈访问修饰符public、private、protected、default在应用设计中的作用。
访问修饰符，主要标示修饰块的作用域，方便隔离防护。

public： Java语言中访问限制最宽的修饰符，一般称之为“公共的”。被其修饰的类、属性以及方法不仅可以跨类访问，而且允许跨包（package）访问。

private: Java语言中对访问权限限制的最窄的修饰符，一般称之为“私有的”。被其修饰的类、属性以及方法只能被该类的对象访问，其子类不能访问，更不能允许跨包访问。

protect: 介于public 和 private 之间的一种访问修饰符，一般称之为“保护形”。被其修饰的类、属性以及方法只能被类本身的方法及子类访问，即使子类在不同的包中也可以访问。

default：即不加任何访问修饰符，通常称为“默认访问模式“。该模式下，只允许在同一个包中进行访问

## 面向对象的特点有哪些？

   1.封装
   
   所谓封装，就是将客观事物封装成抽象的类，并且类可以把数据和方法让可信的类或者对象进行操作，对不可信的类或者对象进行隐藏。
   
   2.继承
   
   继承有这样一种能力，就是能使用现有的类的所有功能，并无须重新编写原来的这些类的基础上对这些功能进行扩展。通过继承创建的新类称为子类或派生类，被继承的称为基类。继承有两种，一种是实现继承，另外一种是接口继承。实现继承可以直接使用基类的属性和方法而无需额外编码，接口继承是指使用属性和方法的名称，但是子必须提供实现的能力。  
   
   3.多态
   
   所谓多态就是对一个实例的相同方法在不同的情形下有不同的表现形式。多态机制使得不同内部结构的对象可以共享相同的外部接口，这就意味着，虽然不同的类的内部操作不同，但可以通过一个公共的类，它们可以通过相同的方式予以调用。

## 什么是值传递和引用传递
   值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量.
   
   引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 。
   
   一般认为,java内的传递都是值传递. java中实例对象的传递是引用传递 。 
## HashMap 与HashTable有什么区别
   
  - HashTable
   底层数组+链表实现，无论key还是value都不能为null，线程安全，实现线程安全的方式是在修改数据时锁住整个HashTable，效率低，ConcurrentHashMap做了相关优化
   
   初始size为11，扩容：newsize = olesize*2+1
   
   计算index的方法：index = (hash & 0x7FFFFFFF) % tab.length
  - HashMap
   底层数组+链表实现，可以存储null键和null值，线程不安全
   
   初始size为16，扩容：newsize = oldsize*2，size一定为2的n次幂
   
   扩容针对整个Map，每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入
   
   插入元素后才判断该不该扩容，有可能无效扩容（插入后如果扩容，如果没有再次插入，就会产生无效扩容）
   
   当Map中元素总数超过Entry数组的75%，触发扩容操作，为了减少链表长度，元素分配更均匀
   
   计算index方法：index = hash & (tab.length – 1)

##   描述动态代理的几种实现方式，分别说出相应的优缺点。
   
   动态代理有两种实现方式，分别是：jdk动态代理和cglib动态代理
   
   jdk动态代理的前提是目标类必须实现一个接口，代理对象跟目标类实现一个接口，从而避过虚拟机的校验。
   
   cglib动态代理是继承并重写目标类，所以目标类和方法不能被声明成final。
## 深拷贝和浅拷贝区别。
   一、拷贝的引入
   （1）、引用拷贝
   
   创建一个指向对象的引用变量的拷贝。
~~~
   Teacher teacher = new Teacher("Taylor",26);
   Teacher otherteacher = teacher;
   System.out.println(teacher);
   System.out.println(otherteacher);
~~~  
   输出结果：
   
   blog.Teacher@355da254
   
   blog.Teacher@355da254
  
   结果分析：由输出结果可以看出，它们的地址值是相同的，那么它们肯定是同一个对象。teacher和otherteacher的只是引用而已，他们都指向了一个相同的对象Teacher(“Taylor”,26)。 这就叫做引用拷贝。
   
   （2）、对象拷贝
   
   创建对象本身的一个副本。
~~~   
   Teacher teacher = new Teacher("Swift",26); 
   Teacher otherteacher = (Teacher)teacher.clone(); 
   System.out.println(teacher);
   System.out.println(otherteacher);
~~~ 
   输出结果：
   
   blog.Teacher@355da254
   
   blog.Teacher@4dc63996
 
   结果分析：由输出结果可以看出，它们的地址是不同的，也就是说创建了新的对象， 而不是把原对象的地址赋给了一个新的引用变量,这就叫做对象拷贝。
   
   
   
   注：深拷贝和浅拷贝都是对象拷贝
   
   二、浅拷贝
   （1）、定义
   
   被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指向原来的对象。即对象的浅拷贝会对“主”对象进行拷贝，但不会复制主对象里面的对象。”里面的对象“会在原来的对象和它的副本之间共享。
   
   简而言之，浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象
  
   结果分析： 两个引用student1和student2指向不同的两个对象，但是两个引用student1和student2中的两个teacher引用指向的是同一个对象，所以说明是浅拷贝。
   
   三、深拷贝
   （1）、定义
   
   深拷贝是一个整个独立的对象拷贝，深拷贝会拷贝所有的属性,并拷贝属性指向的动态分配的内存。当对象和它所引用的对象一起拷贝时即发生深拷贝。深拷贝相比于浅拷贝速度较慢并且花销较大。
   
   简而言之，深拷贝把要复制的对象所引用的对象都复制了一遍。
   
   结果分析：
   两个引用student1和student2指向不同的两个对象，两个引用student1和student2中的两个teacher引用指向的是两个对象，但对teacher对象的修改只能影响student1对象,所以说是深拷贝。

## 在jdk1.5中，引入了泛型，泛型的存在是用来解决什么问题。
   泛型的好处是在编译的时候检查类型安全，并且所有的强制转换都是自动和隐式的，提高代码的重用率。
   
## 什么是序列化，怎么序列化，为什么序列化，反序列化会遇到什么问题，如何解决。
   序列化是一种用来处理对象流的机制 ,所谓对象流就是将对象的内容进行流化。
   
   序列化是为了解决在对对象流进行读写操作时所引发的问题。
   
   序列化的实现：将需要被序列化的类实现Serializable接口，该接口没有需要实现的方法，implements Serializable只是为了标注该对象是可被序列化的，
   
   然后使用一个输出流(如：FileOutputStream)来构造一个ObjectOutputStream(对象流)对象，接着，使用ObjectOutputStream对象的writeObject(Object obj)方法
   
   就可以将参数为obj的对象写出(即保存其状态)，要恢复的话则用输入流;

## java中的throw 和 throws关键字有什么区别？
   
   ~~~java
   public class Test {
          public static void main(String[] args) {
              try {
                  test(args);
              } catch (Exception e) {
                  e.printStackTrace();
              }
          }
       
          public static void test(String[] args) throws Exception {
              if (args == null || args.length != 1 || !"true".equals(args[0])) {
                  throw new IllegalArgumentException("Invalid argument!");
              }
          }
      }
   ~~~
   
   区别：
   
   throw是语句抛出一个异常，一般是在代码块的内部，当程序出现某种逻辑错误时由程序员主动抛出某种特定类型的异常
   
   throws是方法可能抛出异常的声明。(用在声明方法时，表示该方法可能要抛出异常)

## 线程池的作用有哪些？
   
  - 线程池的作用： 在程序启动的时候就创建若干线程来响应处理，它们被称为线程池，里面的线程叫工作线程
  - 第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。
  - 第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。
  - 第三：提高线程的可管理性。
  
  - 常用线程池：ExecutorService 是主要的实现类，其中常用的有
   
   Executors.newSingleThreadPool(),
    
   newFixedThreadPool(),
    
   newCachedTheadPool(),
    
   newScheduledThreadPool()。

## final, finally, finalize有什么区别
   
   final 修饰符（关键字）如果一个类被声明为final，意味着它不能再派生出新的子类，不能作为父类被继承。因此一个类不能既被声明为 abstract的，又被声明为final的。将变量或方法声明为final，可以保证它们在使用中不被改变。被声明为final的变量必须在声明时给定初值，而在以后的引用中只能读取，不可修改。被声明为final的方法也同样只能使用，不能重载 。
   
   finally  在异常处理时提供 finally 块来执行任何清除操作。如果抛出一个异常，那么相匹配的 catch 子句就会执行，然后控制就会进入 finally 块（如果有的话）。 
   
   finalize  方法名。Java 技术允许使用 finalize() 方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。这个方法是由垃圾收集器在确定这个对象没有被引用时对这个对象调用的。它是在 Object类中定义的，因此所有的类都继承了它。子类覆盖 finalize() 方法以整理系统资源或者执行其他清理工作。finalize() 方法是在垃圾收集器删除对象之前对这个对象调用的。

## 反射机制有哪些优点和缺点
   
   1、优点：
   
   静态编译：
   
   在编译时确定类型，绑定对象，即通过。
   
   动态编译：
   
   运行时确定类型，绑定对象。动态编译最大限度的发挥了java的灵活性，体现了多态的应用，有利于降低类之间的耦合性。
   
   一句话，反射机制的优点就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中它的灵活性就表现的十分明显。比如，一个大型的软件，不可能一次就把把它设计的很完美，当这个程序编译后，发布了，当发现需要更新某些功能时，我们不可能要用户把以前的卸载，再重新安装新的版本，假如这样的话，这个软件肯定是没有多少人用的。采用静态的话，需要把整个程序重新编译一次才可以实现功能的更新，而采用反射机制的话，它就可以不用卸载，只需要在运行时才动态的创建和编译，就可以实现该功能。
   
   2、缺点：
   
   是对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作

## finalize()

finalize()是Object中的方法，当垃圾回收器将要回收对象所占内存之前被调用，即当一个对象被虚拟机宣告死亡时会先调用它finalize()方法，让此对象处理它生前的最后事情（这个对象可以趁这个时机挣脱死亡的命运）。

+ 判定死亡

"GC ROOTS"定义：GC管理的主要区域是Java堆，一般情况下只针对堆进行垃圾回收。方法区、栈和本地方法区不被GC所管理,因而选择这些区域内的对象作为GC roots,被GC roots引用的对象不被GC回收。"GC ROOTS"也可以看做是引用链的最顶级。

Java采用可达性分析算法来判定一个对象是否死期已到。Java中以一系列"GC  Roots"对象作为起点，如果一个对象的引用链可以最终追溯到"GC  Roots"对象，那就不会回收。否则具有被垃圾回收器回收的资格。

+ 最后的救赎

上面提到了判断死亡的依据，但被判断死亡后，还有生还的机会。

如何自我救赎：
+ 1.对象覆写了finalize()方法（这样在被判死后才会调用此方法，才有机会做最后的救赎）；
+ 2.在finalize()方法中重新引用到"GC  Roots"链上（如把当前对象的引用this赋值给某对象的类变量/成员变量，重新建立可达的引用）.


+ 需要注意：

finalize()只会在对象内存回收前被调用一次(The finalize method is never invoked more than once by a Java virtual machine for any given object. )；

finalize()的调用具有不确定行，只保证方法会调用，但不保证方法里的任务会被执行完（比如一个对象在自救的过程中，被杀死回收了）。

+ finalize()的作用

虽然以上以对象救赎举例，但finalize()的作用往往被认为是用来做最后的资源回收。

基于在自我救赎中的表现来看，此方法有很大的不确定性（不保证方法中的任务执行完）而且运行代价较高。所以用来回收资源也不会有什么好的表现。

综上：finalize()方法并没有什么用。

至于为什么会存在这样一个鸡肋的方法：书中说“它不是C/C++中的析构函数，而是Java刚诞生时为了使C/C++程序员更容易接受它所做出的一个妥协”。

## 2. finally
   
   finally作为异常处理的一部分，它只能用在try/catch语句中，并且附带一个语句块，表示这段语句最终一定会被执行（不管有没有抛出异常），经常被用在需要释放资源的情况下。（×）（这句话其实存在一定的问题）
   
   只有与finally对应的try语句块得到执行的情况下，finally语句块才会执行。在执行try语句块之前已经返回或抛出异常，所以try对应的finally语句并没有执行。
   
   但是，在某些情况下，即使try语句执行了，finally语句也不一定执行。例如以下情况：
   
   finally 语句块还是没有执行，为什么呢？因为我们在 try 语句块中执行了 System.exit (0) 语句，终止了 Java 虚拟机的运行。当然在一般的 Java 应用中基本上是不会调用这个 System.exit(0) 方法的。OK ！我们不调用 System.exit(0) 这个方法，那么 finally 语句块就一定会执行吗？
   
   答案还是否定的。当一个线程在执行 try 语句块或者 catch 语句块时被打断（interrupted）或者被终止（killed），与其相对应的 finally 语句块可能不会执行。还有更极端的情况，就是在线程运行 try 语句块或者 catch 语句块时，突然死机或者断电，finally 语句块肯定不会执行了。可能有人认为死机、断电这些理由有些强词夺理，没有关系，我们只是为了说明这个问题。
   
   易错点
   
   　　在try-catch-finally语句中执行return语句。因为finally用法特殊，所以会撤销之前的return语句，继续执行最后的finally块中的代码。 
   





































































