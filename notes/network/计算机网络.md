# 网络相关面试题
## TCP 和 UDP 区别，他们位于哪一层？
TCP:
优点提供稳定的传输服务，有流量控制。
缺点包头大，冗余性不好。
UDP:
不提供稳定的服务，包头小，开销小。
传输层。

## 路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？
路由器：
它根据ＩＰ地址进行寻址，通过路由表路由协议产生。
内部网关协议IGP和外部网关协议EGP。
网络层。
交换机：
它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行N/A。
数据链路层。

## 描述TCP 协议三次握手，四次挥放的过程。
三次握手过程描述：
一次握手：建立连接时，客户端发送SYN
包(SYN=j)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1),同时自己也发送一个SYN包（SYN=k），及SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
四次挥放过程描述：
1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 为什么四次挥手等待2MSL
   一、防止第四次挥手的报文段丢失，服务器端无法正常关闭。如果第四次挥手丢失，服务器端会重新发送第三次挥手的报文，请求断开连接。
   
   二、2MSL时间可以保证本次连接所有报文失效，防止“已失效的连接请求报文段”出现在本连接中，避免被服务器端认为是一个新的连接请求。

## TCP 协议是如何进行流量控制，拥塞控制的？
答：
拥塞控制包括四部分：慢启动、拥塞避免、快速重传、快速恢复。
流量控制是通过大小可变的滑动窗口实现的。

## 为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理
三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
两次握手可能产生空的连接（死锁）。
服务端发送 RST 报文，进入 CLOSE 状态。这个 RST 数据包的 TCP 首部中，控制位中的 RST 位被设置为 1。这表示连接信息全部被初始化，原有的 TCP 通信不能继续进行。客户端如果还想重新建立 TCP 连接，就必须重新开始第一次握手。

## 关闭连接时，第四次握手失败怎么处理？
实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。

## 你怎么理解分层和协议？
答：将复杂的网络协议更加简单化。每一个分层都接收由下一层提供的特定服务，并且负责为自己的上一层提供服务。
它实际上是一种通信双方共同遵守的规范。

## HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。
答：GET和POST的区别：
GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据，除了用途上的区别，它们还有以下这些不同：
GET 请求可以被缓存，可以被收藏为书签，但 POST 不行。
GET 请求会保留在浏览器的历史记录中，POST 不会。
GET 请求的长度有限制（不同的浏览器不一样，大约在几 Kb 左右），URL 的数据类型只能是 ASCII 字符，POST 请求没有限制。
GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。
Session和Cookie的区别：
cookie 保存在客户端上，而 session 则保存在服务器中。由此我们还可以拓展出以下结论：
cookie 相对来说不安全，浏览器可以分析本地的 cookie 进行 cookie 欺骗。
session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。
单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。
客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。
当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。

## 谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解。
HTTP/1.1是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP／2.0在HTTP 1.x的基础上，大幅度的提高了web性能，减少了网络延迟。
 
## 简单介绍一下HTTP的长连接和短连接
   HTTP的长连接和短连接本质上是TCP长连接和短连接。HTTP属于应用层协议.
   
   短连接:浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。
   
   长连接:当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭，如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。
   
   Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接要客户端和服务端都支持长连接。
   
   TCP短连接:client向server发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，
   
   这时候双方任何一个都可以发起close操作，不过一般都是client先发起 close操作.短连接一般只会在 client/server间传递一次读写操作
   
   TCP长连接:client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。
   
## 简述计算机网络中的七层模型
   OSI分层      （7层）：物理层、数据链路层、网络层、传输层、会话层、表示层、应用层。
   
   TCP/IP分层（4层）：网络接口层、网际层、运输层、应用层。
   
   五层协议     （5层）：物理层、数据链路层、网络层、运输层、应用层。
    
   每一层的协议如下：
 >  物理层：RJ45、CLOCK、IEEE802.3    （中继器，集线器，网关）
   数据链路：PPP、FR、HDLC、VLAN、MAC  （网桥，交换机）
   网络层：IP、ICMP、ARP、RARP、OSPF、IPX、RIP、IGRP、 （路由器）
   传输层：TCP、UDP、SPX
   会话层：NFS、SQL、NETBIOS、RPC
   表示层：JPEG、MPEG、ASII
   应用层：FTP、DNS、Telnet、SMTP、HTTP、WWW、NFS
    
   每一层的作用如下：
   
  > 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit）
   数据链路层：将比特组装成帧和点到点的传递（帧Frame）
   网络层：负责数据包从源到宿的传递和网际互连（包PackeT）
   传输层：提供端到端的可靠报文传递和错误恢复（段Segment）
   会话层：建立、管理和终止会话（会话协议数据单元SPDU）
   表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU）
   应用层：允许访问OSI环境的手段（应用协议数据单元APDU）

## 常见的HTTP状态码有哪些？

   2开头 （请求成功）表示成功处理了请求的状态代码。
   
   200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。 201 （已创建） 请求成功并且服务器创建了新的资源。 202 （已接受） 服务器已接受请求，但尚未处理。 
   
   203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。 204 （无内容） 服务器成功处理了请求，但没有返回任何内容。 
   
   205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。206 （部分内容） 服务器成功处理了部分 GET 请求。
   
   
   3开头 （请求被重定向）表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。
   
   300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。 301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
    
   302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。 303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。 
   
   304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。 305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。 307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
   
   4开头 （请求错误）这些状态代码表示请求可能出错，妨碍了服务器的处理。
   
   400 （错误请求） 服务器不理解请求的语法。 401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 403 （禁止） 服务器拒绝请求。 404 （未找到） 服务器找不到请求的网页。
    
   405 （方法禁用） 禁用请求中指定的方法。 406 （不接受） 无法使用请求的内容特性响应请求的网页。 407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。 408 （请求超时） 服务器等候请求时发生超时。
    
   409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。 410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。 411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。 412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
    
   413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。 414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。 415 （不支持的媒体类型） 请求的格式不受请求页面的支持。 416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。 417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。
   
   
   5开头（服务器错误）这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。
   
   500 （服务器内部错误） 服务器遇到错误，无法完成请求。 501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。 502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。 
   
   503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。 504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。 505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

## Post和Get有什么区别？

   1、 GET主要用于从服务器查询数据，POST用于向服务器提交数据
   
   2、 GET通过URL传递数据，POST通过http请求体传递数据
   
   3、 GET传输数据量有限制，不能大于2kb，POST传递的数据量较大，一般大量的数据提交都是通过POST方式
   
   4、 GET安全性较低，容易在URL中暴漏数据，POST安全性较高

## TCP和UDP相关的协议分别有哪些？
   
   TCP对应的协议：
   
   （1） FTP：定义了文件传输协议，使用21端口。
   
   （2） Telnet：一种用于远程登陆的端口，使用23端口，用户可以以自己的身份远程连接到计算机上，可提供基于DOS模式下的通信服务。
   
   （3） SMTP：邮件传送协议，用于发送邮件。服务器开放的是25号端口。
   
   （4） POP3：它是和SMTP对应，POP3用于接收邮件。POP3协议所用的是110端口。
   
   （5）HTTP：是从Web服务器传输超文本到本地浏览器的传送协议。
   
   UDP对应的协议：
   
   （1） DNS：用于域名解析服务，将域名地址转换为IP地址。DNS用的是53号端口。
   
   （2） SNMP：简单网络管理协议，使用161号端口，是用来管理网络设备的。由于网络设备很多，无连接的服务就体现出其优势。
   
   （3） TFTP(Trival File Transfer Protocal)，简单文件传输协议，该协议在熟知端口69上使用UDP服务。
   
## 在浏览器中输入www.baidu.com后执行的全部过程
   
   1、客户端浏览器通过DNS解析到www.baidu.com的IP地址220.181.27.48，通过这个IP地址找到客户端到服务器的路径。客户端浏览器发起一个HTTP会话到220.161.27.48，然后通过TCP进行封装数据包，输入到网络层。
   
   2、在客户端的传输层，把HTTP会话请求分成报文段，添加源和目的端口，如服务器使用80端口监听客户端的请求，客户端由系统随机选择一个端口如5000，与服务器进行交换，服务器把相应的请求返回给客户端的5000端口。然后使用IP层的IP地址查找目的端。
   
   3、客户端的网络层不用关系应用层或者传输层的东西，主要做的是通过查找路由表确定如何到达服务器，期间可能经过多个路由器，这些都是由路由器来完成的工作，我不作过多的描述，无非就是通过查找路由表决定通过那个路径到达服务器。
   
   4、客户端的链路层，包通过链路层发送到路由器，通过邻居协议查找给定IP地址的MAC地址，然后发送ARP请求查找目的地址，如果得到回应后就可以使用ARP的请求应答交换的IP数据包现在就可以传输了，然后发送IP数据包到达服务器的地址。

## 列举几种常见的协议，并简述他们的作用

   ICMP协议：因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。
   
   TFTP协议：是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。
   
   HTTP协议：超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。
   
   DHCP协议：动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。
   
   NAT协议：网络地址转换属接入广域网(WAN)技术，是一种将私有（保留）地址转化为合法IP地址的转换技术，
   
   DHCP协议：一个局域网的网络协议，使用UDP协议工作，用途：给内部网络或网络服务供应商自动分配IP地址，给用户或者内部网络管理员作为对所有计算机作中央管理的手段。

## cookie 和 session 有什么区别？
   1、cookie数据存放在客户的浏览器上，session数据放在服务器上。
   
   2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗考虑到安全应当使用session。
   
   3、session会在一定时间内保存在服务器上。当访问增多，会比较占用服务器的性能考虑到减轻服务器性能方面，应当使用COOKIE。
   
   4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。
   
   5、建议：将登陆信息等重要信息存放为SESSION,其他信息如果需要保留，可以放在COOKIE中

## HTTPS与HTTP的一些区别
   
   HTTPS协议需要到CA申请证书，一般免费证书很少，需要交费。
   
   HTTP协议运行在TCP之上，所有传输的内容都是明文，HTTPS运行在SSL/TLS之上，SSL/TLS运行在TCP之上，所有传输的内容都经过加密的。
   
   HTTP和HTTPS使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
   
   HTTPS可以有效的防止运营商劫持，解决了防劫持的一个大问题。
 
## TCP粘包，拆包及解决方法
 >  客户端连续不断的向服务端发送数据包时，服务端接收的数据会出现两个数据包粘在一起的情况，这就是TCP协议中经常会遇到的粘包以及拆包的问题。
   我们都知道TCP属于传输层的协议，传输层除了有TCP协议外还有UDP协议。那么UDP是否会发生粘包或拆包的现象呢？答案是不会。UDP是基于报文发送的，从UDP的帧结构可以看出，
   在UDP首部采用了16bit来指示UDP数据报文的长度，因此在应用层能很好的将不同的数据报文区分开，从而避免粘包和拆包的问题。而TCP是基于字节流的，虽然应用层和TCP传输层之间的数据交互是大小不等的数据块，但是TCP把这些数据块仅仅看成一连串无结构的字节流，没有边界；
   另外从TCP的帧结构也可以看出，在TCP的首部没有表示数据长度的字段，基于上面两点，在使用TCP传输数据时，才有粘包或者拆包现象发生的可能。
   
   粘包、拆包表现形式
   现在假设客户端向服务端连续发送了两个数据包，用packet1和packet2来表示，那么服务端收到的数据可以分为三种
   
   第一种情况，接收端正常收到两个数据包，即没有发生拆包和粘包的现象
   
   第二种情况，接收端只收到一个数据包，由于TCP是不会出现丢包的，所以这一个数据包中包含了发送端发送的两个数据包的信息，这种现象即为粘包。这种情况由于接收端不知道这两个数据包的界限，所以对于接收端来说很难处理。
   
   第三种情况，这种情况有两种表现形式，接收端收到了两个数据包，但是这两个数据包要么是不完整的，要么就是多出来一块，这种情况即发生了拆包和粘包。这两种情况如果不加特殊处理，对于接收端同样是不好处理的。
   
  > 粘包、拆包发生原因
   发生TCP粘包或拆包有很多原因，现列出常见的几点，可能不全面，欢迎补充，
   1、要发送的数据大于TCP发送缓冲区剩余空间大小，将会发生拆包。
   2、待发送数据大于MSS（最大报文长度），TCP在传输前将进行拆包。
   3、要发送的数据小于TCP发送缓冲区的大小，TCP将多次写入缓冲区的数据一次发送出去，将会发生粘包。
   4、接收数据端的应用层没有及时读取接收缓冲区中的数据，将发生粘包。
 
 >  粘包、拆包解决办法
   通过以上分析，我们清楚了粘包或拆包发生的原因，那么如何解决这个问题呢？解决问题的关键在于如何给每个数据包添加边界信息，常用的方法有如下几个：
   1、发送端给每个数据包添加包首部，首部中应该至少包含数据包的长度，这样接收端在接收到数据后，通过读取包首部的长度字段，便知道每一个数据包的实际长度了。
   2、发送端将每个数据包封装为固定长度（不够的可以通过补0填充），这样接收端每次从接收缓冲区中读取固定长度的数据就自然而然的把每个数据包拆分开来。
   3、可以在数据包之间设置边界，如添加特殊符号，这样，接收端通过这个边界就可以将不同的数据包拆分开。








