# 网络相关面试题
## TCP 和 UDP 区别，他们位于哪一层？
TCP:
优点提供稳定的传输服务，有流量控制。
缺点包头大，冗余性不好。
UDP:
不提供稳定的服务，包头小，开销小。
传输层。

## 路由器和交换机的工作原理大概是什么，他们分别用到什么协议，位于哪一层？
路由器：
它根据ＩＰ地址进行寻址，通过路由表路由协议产生。
内部网关协议IGP和外部网关协议EGP。
网络层。
交换机：
它根据MAC地址寻址，通过站表选择路由，站表的建立和维护由交换机自动进行N/A。
数据链路层。

## 描述TCP 协议三次握手，四次挥放的过程。
三次握手过程描述：
一次握手：建立连接时，客户端发送SYN
包(SYN=j)到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号
第二次握手：服务器收到SYN包，必须确认客户的SYN（ACK=j+1),同时自己也发送一个SYN包（SYN=k），及SYN+ACK包，此时服务器进入SYN_RECV状态；
第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK（ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。
四次挥放过程描述：
1）客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。
2）服务器收到连接释放报文，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。
3）客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。
4）服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。
5）客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。
6）服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。

## 为什么四次挥手等待2MSL
   一、防止第四次挥手的报文段丢失，服务器端无法正常关闭。如果第四次挥手丢失，服务器端会重新发送第三次挥手的报文，请求断开连接。
   
   二、2MSL时间可以保证本次连接所有报文失效，防止“已失效的连接请求报文段”出现在本连接中，避免被服务器端认为是一个新的连接请求。

## TCP 协议是如何进行流量控制，拥塞控制的？
答：
拥塞控制包括四部分：慢启动、拥塞避免、快速重传、快速恢复。
流量控制是通过大小可变的滑动窗口实现的。

## 为什么建立连接时是三次握手，两次行不行？如果第三次握手失败了怎么处理
三次握手完成两个重要的功能，既要双方做好发送数据的准备工作(双方都知道彼此已准备好)，也要允许双方就初始序列号进行协商，这个序列号在握手过程中被发送和确认。
两次握手可能产生空的连接（死锁）。
服务端发送 RST 报文，进入 CLOSE 状态。这个 RST 数据包的 TCP 首部中，控制位中的 RST 位被设置为 1。这表示连接信息全部被初始化，原有的 TCP 通信不能继续进行。客户端如果还想重新建立 TCP 连接，就必须重新开始第一次握手。

## 关闭连接时，第四次握手失败怎么处理？
实际上，在第三步中，客户端收到 FIN 包时，它会设置一个计时器，等待相当长的一段时间。如果客户端返回的 ACK 丢失，那么服务端还会重发 FIN 并重置计时器。假设在计时器失效前服务器重发的 FIN 包没有到达客户端，客户端就会进入 CLOSE 状态，从而导致服务端永远无法收到 ACK 确认，也就无法关闭连接。

## 你怎么理解分层和协议？
答：将复杂的网络协议更加简单化。每一个分层都接收由下一层提供的特定服务，并且负责为自己的上一层提供服务。
它实际上是一种通信双方共同遵守的规范。

## HTTP 请求中的 GET 和 POST 的区别，Session 和 Cookie 的区别。
答：GET和POST的区别：
GET 请求通常用于查询、获取数据，而 POST 请求则用于发送数据，除了用途上的区别，它们还有以下这些不同：
GET 请求可以被缓存，可以被收藏为书签，但 POST 不行。
GET 请求会保留在浏览器的历史记录中，POST 不会。
GET 请求的长度有限制（不同的浏览器不一样，大约在几 Kb 左右），URL 的数据类型只能是 ASCII 字符，POST 请求没有限制。
GET 请求的参数在 URL 中，因此绝不能用 GET 请求传输敏感数据。POST 请求数据则写在 HTTP 的请求头中，安全性略高于 GET 请求。
Session和Cookie的区别：
cookie 保存在客户端上，而 session 则保存在服务器中。由此我们还可以拓展出以下结论：
cookie 相对来说不安全，浏览器可以分析本地的 cookie 进行 cookie 欺骗。
session 可以设置超时时间，超过这个时间后就失效，以免长期占用服务端内存。
单个 cookie 的大小有限制（4 Kb），每个站点的 cookie 数量一般也有限制（20个）。
客户端每次都会把 cookie 发送到服务端，因此服务端可以知道 cookie，但是客户端不知道 session。
当服务器接收到 cookie 后，会根据 cookie 中的 SessionID 来找到这个客户的 session。如果没有，则会生成一个新的 SessionID 发送给客户端。

## 谈谈你对 HTTP 1.1，2.0 和 HTTPS 的理解。
HTTP/1.1是当前版本，持久连接被默认采用，并能很好地配合代理服务器工作，还支持以管道方式同时发送多个请求，以便降低线路负载，提高传输速度。HTTP／2.0在HTTP 1.x的基础上，大幅度的提高了web性能，减少了网络延迟。
 