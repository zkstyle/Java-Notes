## volatile关键字
volatile是一种轻量级的同步机制。它可以保证内存可见性以及防止指令重排序，但是不保证原子性

volatile的第一条语义是保证线程间变量的可见性，简单地说就是当线程A对变量X进行了修改后，在线程A后面执行的其他线程能看到变量X的变动，更详细地说是要符合以下两个规则：

- 线程对变量进行修改之后，要立刻回写到主内存。
- 线程对变量读取的时候，要从主内存中读，而不是缓存。

volatile和JMM机制是不可分割的，在谈volatile的时候有必要先了解以下JMM

### JMM(Java内存模型)
JMM是一种抽象的概念模型，实际上并不存在。JMM主要可以将内存看成两块，一块是主内存，用于存放共享变量，线程间共享。

一块是线程私有的工作内存，存放变量副本。每次线程生成的时候都会创建一个私有的工作内存。当线程要操作主内存中的共享

变量的时候需要先将变量复制到自己的工作内存中，在工作内存中对变量副本进行操作，操作完成后再同步回主内存。

同时，Java内存模型还定义了一系列工作内存和主内存之间交互的操作及操作之间的顺序的规则(这规则比较多也比较复杂。

对于共享普通变量来说，约定了变量在工作内存中发生变化了之后，必须要回写到工作内存(迟早要回写但并非马上回写)，

但对于volatile变量则要求工作内存中发生变化之后，必须马上回写到工作内存，而线程读取volatile变量的时候，

必须马上到工作内存中去取最新值而不是读取本地工作内存的副本，此规则保证了前面所说的“当线程A对变量X进行了修改后，

在线程A后面执行的其他线程能看到变量X的变动”。

工作内存可以说是主内存的一份缓存，为了避免缓存的不一致性，所以volatile需要废弃此缓存。但除了内存缓存之外，

在CPU硬件级别也是有缓存的，即寄存器。假如线程A将变量X由0修改为1的时候，CPU是在其缓存内操作，没有及时回写到内存，

那么JVM是无法X=1是能及时被之后执行的线程B看到的，所以JVM在处理volatile变量的时候，也同样用了硬件级别的缓存一致性原则([JUC源码分析](../juc/CAS与Unsafe.md))

### 内存可见性
由JMM模型我们可以看到，每个线程都是再各自的工作内存中进行工作，它们只知道自己把变量改成什么样了，并不知道其他线程把

变量改成什么样子了。这样会出现一种问题：假设主内存中有变量a的值为0，线程A读取变量a并且copy一份副本到自己的工作内存，

线程B也读取变量a且cope一份副本到自己的工作内存，线程A给变量a加上10，线程B给变量a加上20。那么我们期望的结果是最终主

内存中的变量a的值被同步成了30.但是由于线程A和线程B并不知道对方所作的修改，必定有一方将自己的变量副本同步进主内存的时

侯覆盖掉了另外一放的结果，主内存中变量a的值只会是10或者20。如下图所示。

![img](../images/mt01.png)

内存可见性就是每个线程可以感知到其他线程对该变量所做的修改，操作该变量时都会从主内存中取最新的值。还是拿上图的例子来说，

假设线程A对工作内存中的变量a操作完并且通过回主内存后，线程B立马感知该变化，然后从主内存中取出最新的变量a的值，即10，然后对

10加上20然后同步回主内存，那么最终结果就正确了。内存可见性就是一个线程对共享变量做出改变后其他线程能够立即感知该变化，并且从

主内存中获取最新值，然后进行操作。

![img](../images/mt02.png)

### 不保证原子性
那么volatile每次都是从主内存中获取最新的值进行操作为什么不保证原子性呢，每次都获取最新的值去操作那么结果不就肯定正确的吗。其实不然，

在这里我们要明确一个概念，每次线程在对工作内存中的变量副本操作完后要同步回主内存的时候，一时只能有一个线程同步，如果有多个线程要

往主内存中同步，也只有一个会成功，其他线程会被阻塞在外面，并且挂起。是不是很像对主内存上了一把锁呢。

对于i++这种操作，其实底层是被分成了三个指令来执行。

1 从主内存中拿到值到工作内存

2 对i进行累加

3 将累加后的值写入主内存

考虑这么一种情况，线程A和线程B同时对副本变量操作完了，并且都要同步回主内存，这时候只有一个线程能够通过成功，假设线程A成功获得了主

内存的操作权，线程B就被挂起，当线程A同步完毕后，我们都知道cpu速度是超级快的，这时线程B还没被通知到该变量已被更新时线程B就将变量

同步到主内存并且覆盖掉线程A的修改了。因此volatile不保证原子性。

- 如何保证原子性 
1.　加sync（一致性保证，并发性下降）
2.　使用JUC包下的atomicInteger（多次锁，保证一致性）

### 防止指令重排序
我们编写的代码都是被编译成字节码文件然后再去执行的，为了加快程序运行，编译器对指令进行了重排序，程序执行的顺序并不是和我们代码写的顺

序是一样的。比如 int a = 10，b = 20;我们期望的是a先赋值，b再赋值，但是最终执行的时候可能因为指令从排序导致了b先赋值，a后赋值。指令重排序

的前提是数据间不存在数据依赖性。在单线程环境中，不管指令如何重排序，编译器都会保证最后执行结果的正确性。但是在多线程的情况下，可能会出现

各个程序乱序执行，各个线程数据产生了不一致性，运行结果出错等问题。volatile通过加内存屏障进行禁止指令重排序

禁止指令重排底层原理：
volatile实现禁止指令重排优化，从而避免多线程环境下程序出现乱序执行的现象。
内存屏障（Memory Barrier）又称内存栅栏，是一个CPU指令，它的作用有两个：
- 保证特定操作执行的顺序性；
- 保证某些变量的内存可见性（利用该特性实现volatile内存可见性）
 
volatile实现禁止指令重排优化底层原理：

由于编译器和处理器都能执行指令重排优化。如果在指令间插入一条Memory Barrier则会告诉编译器和CPU，不管什么指令都不能和这条Memory Barrier指令重排，

也就是说通过插入内存屏障，就能禁止在内存屏障前后的指令执行重排优化。内存屏障另外一个作用就是强制刷出各种CPU的缓存数据，因此任何CPU上的线程都能读取到这些数据的最新版本。
