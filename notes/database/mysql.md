##分库分表 
分表，能够解决单表数据量过大带来的查询效率下降的问题；
分库，面对高并发的读写访问，当数据库master服务器无法承载写操作压力时，不管如何扩展slave服务器，此时都没有意义。此时，则需要通过数据分库策略，提高数据库并发访问能力。
优点，分库、分表技术优化了数据存储方式，有效减小数据库服务器的负担、缩短查询响应时间。

数据分库、分表存储场景条件

关系型数据库
主从架构(master-slave)
单表数据量在百万、千万级别
数据库面临极高的并发访问
分库、分表实现策略

关键字取模，实现对数据访问进行路由。
分库

举例
按功能分
用户类库、商品类库、订单类库、日志类库等
按地区分
每个城市或省市一个同样的库，如: db_click_bj、db_click_sh 等
横向/水平分表: 解决 表记录太大问题

主要解决问题：

单表过大造成的性能问题；
单表过大造成的单服务器空间问题。
按某个字段分

如：将用户资料附件表分成3个附件分表pre_forum_attachment_[0|1|2]，和1个附件索引表（存储tid和附件id关系），根据tid最后一位判断附件保存在哪个分表中。
按日期分表
日志类、统计类数据表按年、月、日、周分表。如：点击量统计click_201801、click_201802
通过MySQL的merge存储引擎实现
需要创建分表、总表，总表需要merge存储引擎。
示例代码
~~~sql
create table log_merge (
dt datetime not null,
info varchar (100) not null,
　 index (dt)
) engine = merge
union= (log_2017,log_2018) insert_method = last;
~~~
纵向/垂直分表 : 解决 列过多问题

纵向分表常见的方式有根据活跃度分表、根据重要性分表等。
主要解决问题：

表与表之间资源争用问题；
锁争用机率小；
实现核心与非核心的分级存储，如UDB登陆库拆分成一级二级三级库；
数据库同步压力问题。
具体策略

经常组合查询的列放在一个表，常用字段的表可考虑Memory引擎。
不经常使用的字段单独成表。
把text、blob等大字段拆分放在附表。如：把用户文章表分成主表news和从表news_data，主表存标题、关键字、浏览量等，从表存具体内容、模板等。
分库、分表注意事项
维度问题
针对用户购买记录数据，如果按照用户纬度分表，则每个用户的交易记录都保存在同一表中，所以很快很方便的查找到某用户的购买情况，但是某商品被购买的情况则可能分布在多张表中，查找起来比较麻烦。
若按照商品维度分表，方便查找商品购买情况，但查找个人交易记录比较麻烦。
常见解决方案：
通过扫表方式解决，效率太低，不可行。
记录两份数据，一份按照用户纬度分表，一份按照商品维度分表。
通过搜索引擎解决，但如果实时性要求很高，则牵涉到实时搜索问题。
避免分表join操作。关联的表有可能不在同一数据库中。
避免跨库事务
避免在一个事务中修改db0、db1中的表，不仅操作复杂，而且影响效率。
分表宜多不宜少；避免后期可能二次拆分。
尽量同组数据统一DB服务器。例如将卖家a的商品和交易信息都放到db0中，当db1挂了的时候，卖家a相关的东西可以正常使用。即避免多个数据库中的数据产生依赖。

## 主从复制
什么是主从复制？
主从复制是指将主数据库的DDL和DML操作通过二进制日志传到从数据库上，然后在从数据库上对这些日志进行重新执行，从而使从数据库和主数据库的数据保持一致。

主从复制的原理
MySql主库在事务提交时会把数据变更作为事件记录在二进制日志Binlog中；
主库推送二进制日志文件Binlog中的事件到从库的中继日志Relay Log中，之后从库根据中继日志重做数据变更操作，通过逻辑复制来达到主库和从库的数据一致性；
MySql通过三个线程来完成主从库间的数据复制，其中Binlog Dump线程跑在主库上，I/O线程和SQL线程跑着从库上；
当在从库上启动复制时，首先创建I/O线程连接主库，主库随后创建Binlog Dump线程读取数据库事件并发送给I/O线程，I/O线程获取到事件数据后更新到从库的中继日志Relay Log中去，之后从库上的SQL线程读取中继日志Relay Log中更新的数据库事件并应用，如下图所示。

![im](../images/mysql01.webp)
## Bin-log二进制日志三种模式的日志格式
一、STATEMENT
STATEMENT：顾名思义，STATEMENT 格式的 Binlog 记录的是数据库上执行的原生SQL语句；

Statement Level模式
每一条修改数据的sql都会记录到master的bin_log中，slave在复制的时候sql进程会解析成master端执行过的相同的sql在slave库上再次执行。

优点：
statement level下的优点首先就是解决了row level下的缺点，不需要记录每一行的变化，较少bin-log日志量，节约IO，提高性能。因为它只需要记录在master上所执行的语句的细节，以及执行语句时候的上下文信息。

缺点：

由于它是记录执行语句，所以，为了让这些语句在slave端也能正确执行，那么它还必须记录每条语句在执行的时候的一些相关信息，也就是上下文信息，来保证所有语句在slave端能够得到和在master端相同的执行结果。由于mysql更新较快，使mysql的赋值遇到了不小的挑战，自然赋值的时候就会涉及到越复杂的内容，bug也就容易出现。在statement level下，目前就已经发现了不少情况会造成mysql的复制出现问题，主要是修改数据的时候使用了某些特定的函数或者功能的时候会出现。比如：sleep（）函数在有些版本中就不能正确赋值，在存储过程中使用了last_insert_id（）函数，可能会使slave和master上得到不一致的id等等。由于row level是基于每一行记录的裱花，所以不会出现类似的问题。

总结：
Statement level优点：1、解决了row level的缺点，不需要记录每一行的变化；2、日志量少，节约IO，从库应用日志块。

Statement level缺点：一些新功能同步可能会有障碍,比如函数、触发器等。

二、ROW
ROW：这种格式的 Binlog 记录的是数据表的行是怎样被修改的。

Row Level模式
日志中会记录成每一行数据修改的形式，然后在slave端再对相同的数据进行修改。

优点：
在row level的模式下，bin_log中可以不记录执行的sql语句的上下文信息，仅仅只需要记录哪一条记录被修改，修改成什么样。所以row level的日志内容会非常清楚的记录每一行数据修改的细节，非常容易理解。而且不会出现某些特定情况下的存储过程，或fuction，以及trigger的调用或处罚无法被正确复制的问题。

缺点：
row level模式下，所有的执行语句都会记录到日志中，同时都会以每行记录修改的来记录，这样可能会产生大量的日志内容。

总结：
row level的优点：1、记录详细；2、解决statement level模式无法解决的复制问题。

row level的缺点：日志量大，因为是按行来拆分。

三、MIXED
MIXED：混合模式，如果设置了这种格式，MariaDB / MySQL 会在一些特定的情况下自动从 STATEMENT 格式切换到 ROW 格式。例如，包含 UUID 等不确定性函数的语句，引用了系统变量的语句等等。

Mixed模式（混合模式）

实际上就是前两种模式的结合，在mixed模式下，mysql会根据执行的每一条具体的sql语句来区分对待记录的日志形式，也是在statement和row之间选择一种。

新版本中的mysql中对row level模式也做了优化，并不是所有的修改都会以row level来记录，像遇到表结构变更的时候就会以statement模式来记录，如果sql语句确实就是update或者delete等修改数据的语句，那么还是会记录所有行的变更。

总结：

mysql二进制日志格式也推荐大家用mixed；
## 一、索引
B+ Tree 原理
### 1. 数据结构
B Tree 指的是 Balance Tree，也就是平衡树。平衡树是一颗查找树，并且所有叶子节点位于同一层。

B+ Tree 是基于 B Tree 和叶子节点顺序访问指针进行实现，它具有 B Tree 的平衡性，并且通过顺序访问指针来提高区间查询的性能。

在 B+ Tree 中，一个节点中的 key 从左到右非递减排列，如果某个指针的左右相邻 key 分别是 keyi 和 keyi+1，且不为 null，则该指针指向节点的所有 key 大于等于 keyi 且小于等于 keyi+1。

